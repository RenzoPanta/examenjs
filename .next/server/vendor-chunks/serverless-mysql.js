"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/serverless-mysql";
exports.ids = ["vendor-chunks/serverless-mysql"];
exports.modules = {

/***/ "(rsc)/./node_modules/serverless-mysql/index.js":
/*!************************************************!*\
  !*** ./node_modules/serverless-mysql/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst NodeURL = __webpack_require__(/*! url */ \"url\");\n/**\n * This module manages MySQL connections in serverless applications.\n * More detail regarding the MySQL module can be found here:\n * https://github.com/mysqljs/mysql\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @version 1.5.4\n * @license MIT\n */ module.exports = (params)=>{\n    // Mutable values\n    let client = null // Init null client object\n    ;\n    let counter = 0 // Total reuses counter\n    ;\n    let errors = 0 // Error count\n    ;\n    let retries = 0 // Retry count\n    ;\n    let _cfg = {} // MySQL config globals\n    ;\n    let _maxConns = {\n        updated: 0\n    } // Cache max connections\n    ;\n    let _usedConns = {\n        updated: 0\n    } // Cache used connections\n    ;\n    // Common Too Many Connections Errors\n    const tooManyConnsErrors = [\n        \"ER_TOO_MANY_USER_CONNECTIONS\",\n        \"ER_CON_COUNT_ERROR\",\n        \"ER_USER_LIMIT_REACHED\",\n        \"ER_OUT_OF_RESOURCES\",\n        \"PROTOCOL_CONNECTION_LOST\",\n        \"PROTOCOL_SEQUENCE_TIMEOUT\",\n        \"ETIMEDOUT\" // if the connection times out\n    ];\n    // Init setting values\n    let MYSQL, manageConns, cap, base, maxRetries, connUtilization, backoff, zombieMinTimeout, zombieMaxTimeout, maxConnsFreq, usedConnsFreq, onConnect, onConnectError, onRetry, onClose, onError, onKill, onKillError, PromiseLibrary;\n    /********************************************************************/ /**  HELPER/CONVENIENCE FUNCTIONS                                  **/ /********************************************************************/ const getCounter = ()=>counter;\n    const incCounter = ()=>counter++;\n    const resetCounter = ()=>counter = 0;\n    const getClient = ()=>client;\n    const resetClient = ()=>client = null;\n    const resetRetries = ()=>retries = 0;\n    const getErrorCount = ()=>errors;\n    const getConfig = ()=>_cfg;\n    const config = (args)=>{\n        if (typeof args === \"string\") {\n            return Object.assign(_cfg, uriToConnectionConfig(args));\n        }\n        return Object.assign(_cfg, args);\n    };\n    const delay = (ms)=>new PromiseLibrary((res)=>setTimeout(res, ms));\n    const randRange = (min, max)=>Math.floor(Math.random() * (max - min + 1)) + min;\n    const fullJitter = ()=>randRange(0, Math.min(cap, base * 2 ** retries));\n    const decorrelatedJitter = (sleep = 0)=>Math.min(cap, randRange(base, sleep * 3));\n    const uriToConnectionConfig = (connectionString)=>{\n        let uri = undefined;\n        try {\n            uri = new NodeURL.URL(connectionString);\n        } catch (error) {\n            throw new Error(\"Invalid data source URL provided\");\n        }\n        const extraFields = {};\n        for (const [name, value] of uri.searchParams){\n            extraFields[name] = value;\n        }\n        const database = uri.pathname && uri.pathname.startsWith(\"/\") ? uri.pathname.slice(1) : undefined;\n        const connectionFields = {\n            host: uri.hostname ? uri.hostname : undefined,\n            user: uri.username ? uri.username : undefined,\n            port: uri.port ? Number(uri.port) : undefined,\n            password: uri.password ? uri.password : undefined,\n            database\n        };\n        return Object.assign(connectionFields, extraFields);\n    };\n    /********************************************************************/ /**  CONNECTION MANAGEMENT FUNCTIONS                               **/ /********************************************************************/ // Public connect method, handles backoff and catches\n    // TOO MANY CONNECTIONS errors\n    const connect = async (wait)=>{\n        try {\n            await _connect();\n        } catch (e) {\n            if (tooManyConnsErrors.includes(e.code) && retries < maxRetries) {\n                retries++;\n                wait = Number.isInteger(wait) ? wait : 0;\n                let sleep = backoff === \"decorrelated\" ? decorrelatedJitter(wait) : typeof backoff === \"function\" ? backoff(wait, retries) : fullJitter();\n                onRetry(e, retries, sleep, typeof backoff === \"function\" ? \"custom\" : backoff) // fire onRetry event\n                ;\n                await delay(sleep).then(()=>connect(sleep));\n            } else {\n                onConnectError(e) // Fire onConnectError event\n                ;\n                throw new Error(e);\n            }\n        }\n    } // end connect\n    ;\n    // Internal connect method\n    const _connect = ()=>{\n        if (client === null) {\n            resetCounter() // Reset the total use counter\n            ;\n            // Return a new promise\n            return new PromiseLibrary((resolve, reject)=>{\n                // Connect to the MySQL database\n                client = MYSQL.createConnection(_cfg);\n                // Wait until MySQL is connected and ready before moving on\n                client.connect(function(err) {\n                    if (err) {\n                        resetClient();\n                        reject(err);\n                    } else {\n                        resetRetries();\n                        onConnect(client);\n                        return resolve(true);\n                    }\n                });\n                // Add error listener (reset client on failures)\n                client.on(\"error\", async (err)=>{\n                    errors++;\n                    resetClient() // reset client\n                    ;\n                    resetCounter() // reset counter\n                    ;\n                    onError(err) // fire onError event (PROTOCOL_CONNECTION_LOST)\n                    ;\n                });\n            }) // end promise\n            ;\n        // Else the client already exists\n        } else {\n            return PromiseLibrary.resolve();\n        } // end if-else\n    } // end _connect\n    ;\n    // Function called at the end that attempts to clean up zombies\n    // and maintain proper connection limits\n    const end = async ()=>{\n        if (client !== null && manageConns) {\n            incCounter() // increment the reuse counter\n            ;\n            // Check the number of max connections\n            let maxConns = await getMaxConnections();\n            // Check the number of used connections\n            let usedConns = await getTotalConnections();\n            // If over utilization threshold, try and clean up zombies\n            if (usedConns.total / maxConns.total > connUtilization) {\n                // Calculate the zombie timeout\n                let timeout = Math.min(Math.max(usedConns.maxAge, zombieMinTimeout), zombieMaxTimeout);\n                // Kill zombies if they are within the timeout\n                let killedZombies = timeout <= usedConns.maxAge ? await killZombieConnections(timeout) : 0;\n                // If no zombies were cleaned up, close this connection\n                if (killedZombies === 0) {\n                    quit();\n                }\n            // If zombies exist that are more than the max timeout, kill them\n            } else if (usedConns.maxAge > zombieMaxTimeout) {\n                await killZombieConnections(zombieMaxTimeout);\n            }\n        } // end if client\n    } // end end() method\n    ;\n    // Function that explicitly closes the MySQL connection.\n    const quit = ()=>{\n        if (client !== null) {\n            client.end() // Quit the connection.\n            ;\n            resetClient() // reset the client to null\n            ;\n            resetCounter() // reset the reuse counter\n            ;\n            onClose() // fire onClose event\n            ;\n        }\n    };\n    /********************************************************************/ /**  QUERY FUNCTIONS                                               **/ /********************************************************************/ // Main query function\n    const query = async function(...args) {\n        // Establish connection\n        await connect();\n        // Run the query\n        return new PromiseLibrary((resolve, reject)=>{\n            if (client !== null) {\n                // If no args are passed in a transaction, ignore query\n                if (this && this.rollback && args.length === 0) {\n                    return resolve([]);\n                }\n                client.query(...args, async (err, results)=>{\n                    if (err && err.code === \"PROTOCOL_SEQUENCE_TIMEOUT\") {\n                        client.destroy() // destroy connection on timeout\n                        ;\n                        resetClient() // reset the client\n                        ;\n                        reject(err) // reject the promise with the error\n                        ;\n                    } else if (err && (/^PROTOCOL_ENQUEUE_AFTER_/.test(err.code) || err.code === \"PROTOCOL_CONNECTION_LOST\" || err.code === \"EPIPE\" || err.code === \"ECONNRESET\")) {\n                        resetClient() // reset the client\n                        ;\n                        return resolve(query(...args)) // attempt the query again\n                        ;\n                    } else if (err) {\n                        if (this && this.rollback) {\n                            await query(\"ROLLBACK\");\n                            this.rollback(err);\n                        }\n                        reject(err);\n                    }\n                    return resolve(results);\n                });\n            }\n        });\n    } // end query\n    ;\n    // Get the max connections (either for this user or total)\n    const getMaxConnections = async ()=>{\n        // If cache is expired\n        if (Date.now() - _maxConns.updated > maxConnsFreq) {\n            let results = await query(`SELECT IF(@@max_user_connections > 0,\n        LEAST(@@max_user_connections,@@max_connections),\n        @@max_connections) AS total,\n        IF(@@max_user_connections > 0,true,false) AS userLimit`);\n            // Update _maxConns\n            _maxConns = {\n                total: results[0].total || 0,\n                userLimit: results[0].userLimit === 1 ? true : false,\n                updated: Date.now()\n            };\n        } // end if renewing cache\n        return _maxConns;\n    } // end getMaxConnections\n    ;\n    // Get the total connections being used and the longest sleep time\n    const getTotalConnections = async ()=>{\n        // If cache is expired\n        if (Date.now() - _usedConns.updated > usedConnsFreq) {\n            let results = await query(`SELECT COUNT(ID) as total, MAX(time) as max_age\n        FROM information_schema.processlist\n        WHERE (user = ? AND @@max_user_connections > 0) OR true`, [\n                _cfg.user\n            ]);\n            _usedConns = {\n                total: results[0].total || 0,\n                maxAge: results[0].max_age || 0,\n                updated: Date.now()\n            };\n        } // end if refreshing cache\n        return _usedConns;\n    } // end getTotalConnections\n    ;\n    // Kill all zombie connections that are older than the threshold\n    const killZombieConnections = async (timeout)=>{\n        let killedZombies = 0;\n        // Hunt for zombies (just the sleeping ones that this user owns)\n        let zombies = await query(`SELECT ID,time FROM information_schema.processlist\n        WHERE command = 'Sleep' AND time >= ? AND user = ?\n        ORDER BY time DESC`, [\n            !isNaN(timeout) ? timeout : 60 * 15,\n            _cfg.user\n        ]);\n        // Kill zombies\n        for(let i = 0; i < zombies.length; i++){\n            try {\n                await query(\"KILL ?\", zombies[i].ID);\n                onKill(zombies[i]) // fire onKill event\n                ;\n                killedZombies++;\n            } catch (e) {\n                // if (e.code !== 'ER_NO_SUCH_THREAD') console.log(e)\n                onKillError(e) // fire onKillError event\n                ;\n            }\n        } // end for\n        return killedZombies;\n    } // end killZombieConnections\n    ;\n    /********************************************************************/ /**  TRANSACTION MANAGEMENT                                        **/ /********************************************************************/ // Init a transaction object and return methods\n    const transaction = ()=>{\n        let queries = [] // keep track of queries\n        ;\n        let rollback = ()=>{} // default rollback event\n        ;\n        return {\n            query: function(...args) {\n                if (typeof args[0] === \"function\") {\n                    queries.push(args[0]);\n                } else {\n                    queries.push(()=>[\n                            ...args\n                        ]);\n                }\n                return this;\n            },\n            rollback: function(fn) {\n                if (typeof fn === \"function\") {\n                    rollback = fn;\n                }\n                return this;\n            },\n            commit: async function() {\n                return await commit(queries, rollback);\n            }\n        };\n    };\n    // Commit transaction by running queries\n    const commit = async (queries, rollback)=>{\n        let results = [] // keep track of results\n        ;\n        // Start a transaction\n        await query(\"START TRANSACTION\");\n        // Loop through queries\n        for(let i = 0; i < queries.length; i++){\n            // Execute the queries, pass the rollback as context\n            let result = await query.apply({\n                rollback\n            }, queries[i](results[results.length - 1], results));\n            // Add the result to the main results accumulator\n            results.push(result);\n        }\n        // Commit our transaction\n        await query(\"COMMIT\");\n        // Return the results\n        return results;\n    };\n    /********************************************************************/ /**  INITIALIZATION                                                **/ /********************************************************************/ const cfg = typeof params === \"object\" && !Array.isArray(params) ? params : {};\n    MYSQL = cfg.library || __webpack_require__(/*! mysql */ \"(rsc)/./node_modules/mysql/index.js\");\n    PromiseLibrary = cfg.promise || Promise;\n    // Set defaults for connection management\n    manageConns = cfg.manageConns === false ? false : true // default to true\n    ;\n    cap = Number.isInteger(cfg.cap) ? cfg.cap : 100 // default to 100 ms\n    ;\n    base = Number.isInteger(cfg.base) ? cfg.base : 2 // default to 2 ms\n    ;\n    maxRetries = Number.isInteger(cfg.maxRetries) ? cfg.maxRetries : 50 // default to 50 attempts\n    ;\n    backoff = typeof cfg.backoff === \"function\" ? cfg.backoff : cfg.backoff && [\n        \"full\",\n        \"decorrelated\"\n    ].includes(cfg.backoff.toLowerCase()) ? cfg.backoff.toLowerCase() : \"full\" // default to full Jitter\n    ;\n    connUtilization = !isNaN(cfg.connUtilization) ? cfg.connUtilization : 0.8 // default to 0.7\n    ;\n    zombieMinTimeout = Number.isInteger(cfg.zombieMinTimeout) ? cfg.zombieMinTimeout : 3 // default to 3 seconds\n    ;\n    zombieMaxTimeout = Number.isInteger(cfg.zombieMaxTimeout) ? cfg.zombieMaxTimeout : 60 * 15 // default to 15 minutes\n    ;\n    maxConnsFreq = Number.isInteger(cfg.maxConnsFreq) ? cfg.maxConnsFreq : 15 * 1000 // default to 15 seconds\n    ;\n    usedConnsFreq = Number.isInteger(cfg.usedConnsFreq) ? cfg.usedConnsFreq : 0 // default to 0 ms\n    ;\n    // Event handlers\n    onConnect = typeof cfg.onConnect === \"function\" ? cfg.onConnect : ()=>{};\n    onConnectError = typeof cfg.onConnectError === \"function\" ? cfg.onConnectError : ()=>{};\n    onRetry = typeof cfg.onRetry === \"function\" ? cfg.onRetry : ()=>{};\n    onClose = typeof cfg.onClose === \"function\" ? cfg.onClose : ()=>{};\n    onError = typeof cfg.onError === \"function\" ? cfg.onError : ()=>{};\n    onKill = typeof cfg.onKill === \"function\" ? cfg.onKill : ()=>{};\n    onKillError = typeof cfg.onKillError === \"function\" ? cfg.onKillError : ()=>{};\n    let connCfg = {};\n    if (typeof cfg.config === \"object\" && !Array.isArray(cfg.config)) {\n        connCfg = cfg.config;\n    } else if (typeof params === \"string\") {\n        connCfg = params;\n    }\n    let escape = MYSQL.escape;\n    let escapeId = MYSQL.escapeId;\n    let format = MYSQL.format;\n    // Set MySQL configs\n    config(connCfg);\n    // Return public methods\n    return {\n        connect,\n        config,\n        query,\n        end,\n        escape,\n        escapeId,\n        format,\n        quit,\n        transaction,\n        getCounter,\n        getClient,\n        getConfig,\n        getErrorCount\n    };\n} // end exports\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VydmVybGVzcy1teXNxbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXhCOzs7Ozs7O0NBT0MsR0FFREMsT0FBT0MsT0FBTyxHQUFHLENBQUNDO0lBRWhCLGlCQUFpQjtJQUNqQixJQUFJQyxTQUFTLEtBQUssMEJBQTBCOztJQUM1QyxJQUFJQyxVQUFVLEVBQUUsdUJBQXVCOztJQUN2QyxJQUFJQyxTQUFTLEVBQUUsY0FBYzs7SUFDN0IsSUFBSUMsVUFBVSxFQUFFLGNBQWM7O0lBQzlCLElBQUlDLE9BQU8sQ0FBQyxFQUFFLHVCQUF1Qjs7SUFFckMsSUFBSUMsWUFBWTtRQUFFQyxTQUFTO0lBQUUsRUFBRSx3QkFBd0I7O0lBQ3ZELElBQUlDLGFBQWE7UUFBRUQsU0FBUztJQUFFLEVBQUUseUJBQXlCOztJQUV6RCxxQ0FBcUM7SUFDckMsTUFBTUUscUJBQXFCO1FBQ3pCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLFlBQVksOEJBQThCO0tBQzNDO0lBRUQsc0JBQXNCO0lBQ3RCLElBQUlDLE9BQU9DLGFBQWFDLEtBQUtDLE1BQU1DLFlBQVlDLGlCQUFpQkMsU0FDOURDLGtCQUFrQkMsa0JBQWtCQyxjQUFjQyxlQUNsREMsV0FBV0MsZ0JBQWdCQyxTQUFTQyxTQUFTQyxTQUFTQyxRQUFRQyxhQUFhQztJQUU3RSxvRUFBb0UsR0FDcEUsb0VBQW9FLEdBQ3BFLG9FQUFvRSxHQUVwRSxNQUFNQyxhQUFhLElBQU0zQjtJQUN6QixNQUFNNEIsYUFBYSxJQUFNNUI7SUFDekIsTUFBTTZCLGVBQWUsSUFBTTdCLFVBQVU7SUFDckMsTUFBTThCLFlBQVksSUFBTS9CO0lBQ3hCLE1BQU1nQyxjQUFjLElBQU1oQyxTQUFTO0lBQ25DLE1BQU1pQyxlQUFlLElBQU05QixVQUFVO0lBQ3JDLE1BQU0rQixnQkFBZ0IsSUFBTWhDO0lBQzVCLE1BQU1pQyxZQUFZLElBQU0vQjtJ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SUFDbkVDLFVBQVUsT0FBT2tHLElBQUlsRyxPQUFPLEtBQUssYUFBYWtHLElBQUlsRyxPQUFPLEdBQUcsS0FBTztJQUNuRUMsVUFBVSxPQUFPaUcsSUFBSWpHLE9BQU8sS0FBSyxhQUFhaUcsSUFBSWpHLE9BQU8sR0FBRyxLQUFPO0lBQ25FQyxTQUFTLE9BQU9nRyxJQUFJaEcsTUFBTSxLQUFLLGFBQWFnRyxJQUFJaEcsTUFBTSxHQUFHLEtBQU87SUFDaEVDLGNBQWMsT0FBTytGLElBQUkvRixXQUFXLEtBQUssYUFBYStGLElBQUkvRixXQUFXLEdBQUcsS0FBTztJQUUvRSxJQUFJc0csVUFBVSxDQUFDO0lBRWYsSUFBSSxPQUFPUCxJQUFJckYsTUFBTSxLQUFLLFlBQVksQ0FBQ3NGLE1BQU1DLE9BQU8sQ0FBQ0YsSUFBSXJGLE1BQU0sR0FBRztRQUNoRTRGLFVBQVVQLElBQUlyRixNQUFNO0lBQ3RCLE9BQU8sSUFBSSxPQUFPckMsV0FBVyxVQUFVO1FBQ3JDaUksVUFBVWpJO0lBQ1o7SUFFQSxJQUFJa0ksU0FBU3hILE1BQU13SCxNQUFNO0lBQ3pCLElBQUlDLFdBQVd6SCxNQUFNeUgsUUFBUTtJQUM3QixJQUFJQyxTQUFTMUgsTUFBTTBILE1BQU07SUFFekIsb0JBQW9CO0lBQ3BCL0YsT0FBTzRGO0lBR1Asd0JBQXdCO0lBQ3hCLE9BQU87UUFDTHBEO1FBQ0F4QztRQUNBZ0U7UUFDQVg7UUFDQXdDO1FBQ0FDO1FBQ0FDO1FBQ0FoQztRQUNBZTtRQUNBdEY7UUFDQUc7UUFDQUk7UUFDQUQ7SUFDRjtBQUVGLEVBQUUsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1lbmpzLy4vbm9kZV9tb2R1bGVzL3NlcnZlcmxlc3MtbXlzcWwvaW5kZXguanM/Y2Y5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgTm9kZVVSTCA9IHJlcXVpcmUoJ3VybCcpXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgbWFuYWdlcyBNeVNRTCBjb25uZWN0aW9ucyBpbiBzZXJ2ZXJsZXNzIGFwcGxpY2F0aW9ucy5cbiAqIE1vcmUgZGV0YWlsIHJlZ2FyZGluZyB0aGUgTXlTUUwgbW9kdWxlIGNhbiBiZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL215c3FsanMvbXlzcWxcbiAqIEBhdXRob3IgSmVyZW15IERhbHkgPGplcmVteUBqZXJlbXlkYWx5LmNvbT5cbiAqIEB2ZXJzaW9uIDEuNS40XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IChwYXJhbXMpID0+IHtcblxuICAvLyBNdXRhYmxlIHZhbHVlc1xuICBsZXQgY2xpZW50ID0gbnVsbCAvLyBJbml0IG51bGwgY2xpZW50IG9iamVjdFxuICBsZXQgY291bnRlciA9IDAgLy8gVG90YWwgcmV1c2VzIGNvdW50ZXJcbiAgbGV0IGVycm9ycyA9IDAgLy8gRXJyb3IgY291bnRcbiAgbGV0IHJldHJpZXMgPSAwIC8vIFJldHJ5IGNvdW50XG4gIGxldCBfY2ZnID0ge30gLy8gTXlTUUwgY29uZmlnIGdsb2JhbHNcblxuICBsZXQgX21heENvbm5zID0geyB1cGRhdGVkOiAwIH0gLy8gQ2FjaGUgbWF4IGNvbm5lY3Rpb25zXG4gIGxldCBfdXNlZENvbm5zID0geyB1cGRhdGVkOiAwIH0gLy8gQ2FjaGUgdXNlZCBjb25uZWN0aW9uc1xuXG4gIC8vIENvbW1vbiBUb28gTWFueSBDb25uZWN0aW9ucyBFcnJvcnNcbiAgY29uc3QgdG9vTWFueUNvbm5zRXJyb3JzID0gW1xuICAgICdFUl9UT09fTUFOWV9VU0VSX0NPTk5FQ1RJT05TJyxcbiAgICAnRVJfQ09OX0NPVU5UX0VSUk9SJyxcbiAgICAnRVJfVVNFUl9MSU1JVF9SRUFDSEVEJyxcbiAgICAnRVJfT1VUX09GX1JFU09VUkNFUycsXG4gICAgJ1BST1RPQ09MX0NPTk5FQ1RJT05fTE9TVCcsIC8vIGlmIHRoZSBjb25uZWN0aW9uIGlzIGxvc3RcbiAgICAnUFJPVE9DT0xfU0VRVUVOQ0VfVElNRU9VVCcsIC8vIGlmIHRoZSBjb25uZWN0aW9uIHRpbWVzIG91dFxuICAgICdFVElNRURPVVQnIC8vIGlmIHRoZSBjb25uZWN0aW9uIHRpbWVzIG91dFxuICBdXG5cbiAgLy8gSW5pdCBzZXR0aW5nIHZhbHVlc1xuICBsZXQgTVlTUUwsIG1hbmFnZUNvbm5zLCBjYXAsIGJhc2UsIG1heFJldHJpZXMsIGNvbm5VdGlsaXphdGlvbiwgYmFja29mZixcbiAgICB6b21iaWVNaW5UaW1lb3V0LCB6b21iaWVNYXhUaW1lb3V0LCBtYXhDb25uc0ZyZXEsIHVzZWRDb25uc0ZyZXEsXG4gICAgb25Db25uZWN0LCBvbkNvbm5lY3RFcnJvciwgb25SZXRyeSwgb25DbG9zZSwgb25FcnJvciwgb25LaWxsLCBvbktpbGxFcnJvciwgUHJvbWlzZUxpYnJhcnlcblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKiAgSEVMUEVSL0NPTlZFTklFTkNFIEZVTkNUSU9OUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIGNvbnN0IGdldENvdW50ZXIgPSAoKSA9PiBjb3VudGVyXG4gIGNvbnN0IGluY0NvdW50ZXIgPSAoKSA9PiBjb3VudGVyKytcbiAgY29uc3QgcmVzZXRDb3VudGVyID0gKCkgPT4gY291bnRlciA9IDBcbiAgY29uc3QgZ2V0Q2xpZW50ID0gKCkgPT4gY2xpZW50XG4gIGNvbnN0IHJlc2V0Q2xpZW50ID0gKCkgPT4gY2xpZW50ID0gbnVsbFxuICBjb25zdCByZXNldFJldHJpZXMgPSAoKSA9PiByZXRyaWVzID0gMFxuICBjb25zdCBnZXRFcnJvckNvdW50ID0gKCkgPT4gZXJyb3JzXG4gIGNvbnN0IGdldENvbmZpZyA9ICgpID0+IF9jZmdcbiAgY29uc3QgY29uZmlnID0gKGFyZ3MpID0+IHtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihfY2ZnLHVyaVRvQ29ubmVjdGlvbkNvbmZpZyhhcmdzKSlcbiAgICB9IFxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKF9jZmcsYXJncylcbiAgfVxuICBjb25zdCBkZWxheSA9IG1zID0+IG5ldyBQcm9taXNlTGlicmFyeShyZXMgPT4gc2V0VGltZW91dChyZXMsIG1zKSlcbiAgY29uc3QgcmFuZFJhbmdlID0gKG1pbixtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW5cbiAgY29uc3QgZnVsbEppdHRlciA9ICgpID0+IHJhbmRSYW5nZSgwLCBNYXRoLm1pbihjYXAsIGJhc2UgKiAyICoqIHJldHJpZXMpKVxuICBjb25zdCBkZWNvcnJlbGF0ZWRKaXR0ZXIgPSAoc2xlZXA9MCkgPT4gTWF0aC5taW4oY2FwLCByYW5kUmFuZ2UoYmFzZSwgc2xlZXAgKiAzKSlcbiAgY29uc3QgdXJpVG9Db25uZWN0aW9uQ29uZmlnID0gKGNvbm5lY3Rpb25TdHJpbmcpID0+IHtcbiAgICBsZXQgdXJpID0gdW5kZWZpbmVkXG5cbiAgICB0cnkge1xuICAgICAgdXJpID0gbmV3IE5vZGVVUkwuVVJMKGNvbm5lY3Rpb25TdHJpbmcpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHNvdXJjZSBVUkwgcHJvdmlkZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IGV4dHJhRmllbGRzID0ge31cblxuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiB1cmkuc2VhcmNoUGFyYW1zKSB7XG4gICAgICBleHRyYUZpZWxkc1tuYW1lXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgY29uc3QgZGF0YWJhc2UgPSB1cmkucGF0aG5hbWUgJiYgdXJpLnBhdGhuYW1lLnN0YXJ0c1dpdGgoJy8nKSA/IHVyaS5wYXRobmFtZS5zbGljZSgxKSA6IHVuZGVmaW5lZCAgXG5cbiAgICBjb25zdCBjb25uZWN0aW9uRmllbGRzID0gIHtcbiAgICAgIGhvc3Q6IHVyaS5ob3N0bmFtZSA/IHVyaS5ob3N0bmFtZSA6IHVuZGVmaW5lZCxcbiAgICAgIHVzZXI6IHVyaS51c2VybmFtZSA/IHVyaS51c2VybmFtZSA6IHVuZGVmaW5lZCxcbiAgICAgIHBvcnQ6IHVyaS5wb3J0ID8gTnVtYmVyKHVyaS5wb3J0KSA6IHVuZGVmaW5lZCxcbiAgICAgIHBhc3N3b3JkOiB1cmkucGFzc3dvcmQgPyB1cmkucGFzc3dvcmQgOiB1bmRlZmluZWQsXG4gICAgICBkYXRhYmFzZVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNvbm5lY3Rpb25GaWVsZHMsIGV4dHJhRmllbGRzKVxuICB9XG5cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKiAgQ09OTkVDVElPTiBNQU5BR0VNRU5UIEZVTkNUSU9OUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8vIFB1YmxpYyBjb25uZWN0IG1ldGhvZCwgaGFuZGxlcyBiYWNrb2ZmIGFuZCBjYXRjaGVzXG4gIC8vIFRPTyBNQU5ZIENPTk5FQ1RJT05TIGVycm9yc1xuICBjb25zdCBjb25uZWN0ID0gYXN5bmMgKHdhaXQpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgX2Nvbm5lY3QoKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgaWYgKHRvb01hbnlDb25uc0Vycm9ycy5pbmNsdWRlcyhlLmNvZGUpICYmIHJldHJpZXMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIHJldHJpZXMrK1xuICAgICAgICB3YWl0ID0gTnVtYmVyLmlzSW50ZWdlcih3YWl0KSA/IHdhaXQgOiAwXG4gICAgICAgIGxldCBzbGVlcCA9IGJhY2tvZmYgPT09ICdkZWNvcnJlbGF0ZWQnID8gZGVjb3JyZWxhdGVkSml0dGVyKHdhaXQpIDpcbiAgICAgICAgICB0eXBlb2YgYmFja29mZiA9PT0gJ2Z1bmN0aW9uJyA/IGJhY2tvZmYod2FpdCxyZXRyaWVzKSA6XG4gICAgICAgICAgICBmdWxsSml0dGVyKClcbiAgICAgICAgb25SZXRyeShlLHJldHJpZXMsc2xlZXAsdHlwZW9mIGJhY2tvZmYgPT09ICdmdW5jdGlvbicgPyAnY3VzdG9tJyA6IGJhY2tvZmYpIC8vIGZpcmUgb25SZXRyeSBldmVudFxuICAgICAgICBhd2FpdCBkZWxheShzbGVlcCkudGhlbigoKSA9PiBjb25uZWN0KHNsZWVwKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uQ29ubmVjdEVycm9yKGUpIC8vIEZpcmUgb25Db25uZWN0RXJyb3IgZXZlbnRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpXG4gICAgICB9XG4gICAgfVxuICB9IC8vIGVuZCBjb25uZWN0XG5cbiAgLy8gSW50ZXJuYWwgY29ubmVjdCBtZXRob2RcbiAgY29uc3QgX2Nvbm5lY3QgPSAoKSA9PiB7XG5cbiAgICBpZiAoY2xpZW50ID09PSBudWxsKSB7IC8vIGlmIG5vIGNsaWVudCBjb25uZWN0aW9uIGV4aXN0c1xuXG4gICAgICByZXNldENvdW50ZXIoKSAvLyBSZXNldCB0aGUgdG90YWwgdXNlIGNvdW50ZXJcblxuICAgICAgLy8gUmV0dXJuIGEgbmV3IHByb21pc2VcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZUxpYnJhcnkoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIE15U1FMIGRhdGFiYXNlXG4gICAgICAgIGNsaWVudCA9IE1ZU1FMLmNyZWF0ZUNvbm5lY3Rpb24oX2NmZylcblxuICAgICAgICAvLyBXYWl0IHVudGlsIE15U1FMIGlzIGNvbm5lY3RlZCBhbmQgcmVhZHkgYmVmb3JlIG1vdmluZyBvblxuICAgICAgICBjbGllbnQuY29ubmVjdChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXNldENsaWVudCgpXG4gICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNldFJldHJpZXMoKVxuICAgICAgICAgICAgb25Db25uZWN0KGNsaWVudClcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIEFkZCBlcnJvciBsaXN0ZW5lciAocmVzZXQgY2xpZW50IG9uIGZhaWx1cmVzKVxuICAgICAgICBjbGllbnQub24oJ2Vycm9yJywgYXN5bmMgZXJyID0+IHtcbiAgICAgICAgICBlcnJvcnMrK1xuICAgICAgICAgIHJlc2V0Q2xpZW50KCkgLy8gcmVzZXQgY2xpZW50XG4gICAgICAgICAgcmVzZXRDb3VudGVyKCkgLy8gcmVzZXQgY291bnRlclxuICAgICAgICAgIG9uRXJyb3IoZXJyKSAvLyBmaXJlIG9uRXJyb3IgZXZlbnQgKFBST1RPQ09MX0NPTk5FQ1RJT05fTE9TVClcbiAgICAgICAgfSlcbiAgICAgIH0pIC8vIGVuZCBwcm9taXNlXG5cbiAgICAvLyBFbHNlIHRoZSBjbGllbnQgYWxyZWFkeSBleGlzdHNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2VMaWJyYXJ5LnJlc29sdmUoKVxuICAgIH0gLy8gZW5kIGlmLWVsc2VcblxuICB9IC8vIGVuZCBfY29ubmVjdFxuXG5cbiAgLy8gRnVuY3Rpb24gY2FsbGVkIGF0IHRoZSBlbmQgdGhhdCBhdHRlbXB0cyB0byBjbGVhbiB1cCB6b21iaWVzXG4gIC8vIGFuZCBtYWludGFpbiBwcm9wZXIgY29ubmVjdGlvbiBsaW1pdHNcbiAgY29uc3QgZW5kID0gYXN5bmMgKCkgPT4ge1xuXG4gICAgaWYgKGNsaWVudCAhPT0gbnVsbCAmJiBtYW5hZ2VDb25ucykge1xuXG4gICAgICBpbmNDb3VudGVyKCkgLy8gaW5jcmVtZW50IHRoZSByZXVzZSBjb3VudGVyXG5cbiAgICAgIC8vIENoZWNrIHRoZSBudW1iZXIgb2YgbWF4IGNvbm5lY3Rpb25zXG4gICAgICBsZXQgbWF4Q29ubnMgPSBhd2FpdCBnZXRNYXhDb25uZWN0aW9ucygpXG5cbiAgICAgIC8vIENoZWNrIHRoZSBudW1iZXIgb2YgdXNlZCBjb25uZWN0aW9uc1xuICAgICAgbGV0IHVzZWRDb25ucyA9IGF3YWl0IGdldFRvdGFsQ29ubmVjdGlvbnMoKVxuXG4gICAgICAvLyBJZiBvdmVyIHV0aWxpemF0aW9uIHRocmVzaG9sZCwgdHJ5IGFuZCBjbGVhbiB1cCB6b21iaWVzXG4gICAgICBpZiAodXNlZENvbm5zLnRvdGFsL21heENvbm5zLnRvdGFsID4gY29ublV0aWxpemF0aW9uKSB7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB6b21iaWUgdGltZW91dFxuICAgICAgICBsZXQgdGltZW91dCA9IE1hdGgubWluKE1hdGgubWF4KHVzZWRDb25ucy5tYXhBZ2Usem9tYmllTWluVGltZW91dCksem9tYmllTWF4VGltZW91dClcblxuICAgICAgICAvLyBLaWxsIHpvbWJpZXMgaWYgdGhleSBhcmUgd2l0aGluIHRoZSB0aW1lb3V0XG4gICAgICAgIGxldCBraWxsZWRab21iaWVzID0gdGltZW91dCA8PSB1c2VkQ29ubnMubWF4QWdlID8gYXdhaXQga2lsbFpvbWJpZUNvbm5lY3Rpb25zKHRpbWVvdXQpIDogMFxuXG4gICAgICAgIC8vIElmIG5vIHpvbWJpZXMgd2VyZSBjbGVhbmVkIHVwLCBjbG9zZSB0aGlzIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKGtpbGxlZFpvbWJpZXMgPT09IDApIHtcbiAgICAgICAgICBxdWl0KClcbiAgICAgICAgfVxuXG4gICAgICAvLyBJZiB6b21iaWVzIGV4aXN0IHRoYXQgYXJlIG1vcmUgdGhhbiB0aGUgbWF4IHRpbWVvdXQsIGtpbGwgdGhlbVxuICAgICAgfSBlbHNlIGlmICh1c2VkQ29ubnMubWF4QWdlID4gem9tYmllTWF4VGltZW91dCkge1xuICAgICAgICBhd2FpdCBraWxsWm9tYmllQ29ubmVjdGlvbnMoem9tYmllTWF4VGltZW91dClcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBpZiBjbGllbnRcbiAgfSAvLyBlbmQgZW5kKCkgbWV0aG9kXG5cblxuICAvLyBGdW5jdGlvbiB0aGF0IGV4cGxpY2l0bHkgY2xvc2VzIHRoZSBNeVNRTCBjb25uZWN0aW9uLlxuICBjb25zdCBxdWl0ID0gKCkgPT4ge1xuICAgIGlmIChjbGllbnQgIT09IG51bGwpIHtcbiAgICAgIGNsaWVudC5lbmQoKSAvLyBRdWl0IHRoZSBjb25uZWN0aW9uLlxuICAgICAgcmVzZXRDbGllbnQoKSAvLyByZXNldCB0aGUgY2xpZW50IHRvIG51bGxcbiAgICAgIHJlc2V0Q291bnRlcigpIC8vIHJlc2V0IHRoZSByZXVzZSBjb3VudGVyXG4gICAgICBvbkNsb3NlKCkgLy8gZmlyZSBvbkNsb3NlIGV2ZW50XG4gICAgfVxuICB9XG5cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKiAgUVVFUlkgRlVOQ1RJT05TICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8vIE1haW4gcXVlcnkgZnVuY3Rpb25cbiAgY29uc3QgcXVlcnkgPSBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG5cbiAgICAvLyBFc3RhYmxpc2ggY29ubmVjdGlvblxuICAgIGF3YWl0IGNvbm5lY3QoKVxuXG4gICAgLy8gUnVuIHRoZSBxdWVyeVxuICAgIHJldHVybiBuZXcgUHJvbWlzZUxpYnJhcnkoKHJlc29sdmUscmVqZWN0KSA9PiB7XG4gICAgICBpZiAoY2xpZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIG5vIGFyZ3MgYXJlIHBhc3NlZCBpbiBhIHRyYW5zYWN0aW9uLCBpZ25vcmUgcXVlcnlcbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5yb2xsYmFjayAmJiBhcmdzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gcmVzb2x2ZShbXSkgfVxuICAgICAgICBjbGllbnQucXVlcnkoLi4uYXJncywgYXN5bmMgKGVyciwgcmVzdWx0cykgPT4ge1xuICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdQUk9UT0NPTF9TRVFVRU5DRV9USU1FT1VUJykge1xuICAgICAgICAgICAgY2xpZW50LmRlc3Ryb3koKSAvLyBkZXN0cm95IGNvbm5lY3Rpb24gb24gdGltZW91dFxuICAgICAgICAgICAgcmVzZXRDbGllbnQoKSAvLyByZXNldCB0aGUgY2xpZW50XG4gICAgICAgICAgICByZWplY3QoZXJyKSAvLyByZWplY3QgdGhlIHByb21pc2Ugd2l0aCB0aGUgZXJyb3JcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgZXJyICYmICgvXlBST1RPQ09MX0VOUVVFVUVfQUZURVJfLy50ZXN0KGVyci5jb2RlKSBcbiAgICAgICAgICAgIHx8IGVyci5jb2RlID09PSAnUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUJyBcbiAgICAgICAgICAgIHx8IGVyci5jb2RlID09PSAnRVBJUEUnXG4gICAgICAgICAgICB8fCBlcnIuY29kZSA9PT0gJ0VDT05OUkVTRVQnKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmVzZXRDbGllbnQoKSAvLyByZXNldCB0aGUgY2xpZW50XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShxdWVyeSguLi5hcmdzKSkgLy8gYXR0ZW1wdCB0aGUgcXVlcnkgYWdhaW5cbiAgICAgICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5yb2xsYmFjaykge1xuICAgICAgICAgICAgICBhd2FpdCBxdWVyeSgnUk9MTEJBQ0snKVxuICAgICAgICAgICAgICB0aGlzLnJvbGxiYWNrKGVycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdHMpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICB9IC8vIGVuZCBxdWVyeVxuXG5cbiAgLy8gR2V0IHRoZSBtYXggY29ubmVjdGlvbnMgKGVpdGhlciBmb3IgdGhpcyB1c2VyIG9yIHRvdGFsKVxuICBjb25zdCBnZXRNYXhDb25uZWN0aW9ucyA9IGFzeW5jICgpID0+IHtcblxuICAgIC8vIElmIGNhY2hlIGlzIGV4cGlyZWRcbiAgICBpZiAoRGF0ZS5ub3coKS1fbWF4Q29ubnMudXBkYXRlZCA+IG1heENvbm5zRnJlcSkge1xuXG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IHF1ZXJ5KFxuICAgICAgICBgU0VMRUNUIElGKEBAbWF4X3VzZXJfY29ubmVjdGlvbnMgPiAwLFxuICAgICAgICBMRUFTVChAQG1heF91c2VyX2Nvbm5lY3Rpb25zLEBAbWF4X2Nvbm5lY3Rpb25zKSxcbiAgICAgICAgQEBtYXhfY29ubmVjdGlvbnMpIEFTIHRvdGFsLFxuICAgICAgICBJRihAQG1heF91c2VyX2Nvbm5lY3Rpb25zID4gMCx0cnVlLGZhbHNlKSBBUyB1c2VyTGltaXRgXG4gICAgICApXG5cbiAgICAgIC8vIFVwZGF0ZSBfbWF4Q29ubnNcbiAgICAgIF9tYXhDb25ucyA9IHtcbiAgICAgICAgdG90YWw6IHJlc3VsdHNbMF0udG90YWwgfHwgMCxcbiAgICAgICAgdXNlckxpbWl0OiByZXN1bHRzWzBdLnVzZXJMaW1pdCA9PT0gMSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgdXBkYXRlZDogRGF0ZS5ub3coKVxuICAgICAgfVxuXG4gICAgfSAvLyBlbmQgaWYgcmVuZXdpbmcgY2FjaGVcblxuICAgIHJldHVybiBfbWF4Q29ubnNcblxuICB9IC8vIGVuZCBnZXRNYXhDb25uZWN0aW9uc1xuXG5cbiAgLy8gR2V0IHRoZSB0b3RhbCBjb25uZWN0aW9ucyBiZWluZyB1c2VkIGFuZCB0aGUgbG9uZ2VzdCBzbGVlcCB0aW1lXG4gIGNvbnN0IGdldFRvdGFsQ29ubmVjdGlvbnMgPSBhc3luYyAoKSA9PiB7XG5cbiAgICAvLyBJZiBjYWNoZSBpcyBleHBpcmVkXG4gICAgaWYgKERhdGUubm93KCktX3VzZWRDb25ucy51cGRhdGVkID4gdXNlZENvbm5zRnJlcSkge1xuXG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IHF1ZXJ5KFxuICAgICAgICBgU0VMRUNUIENPVU5UKElEKSBhcyB0b3RhbCwgTUFYKHRpbWUpIGFzIG1heF9hZ2VcbiAgICAgICAgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEucHJvY2Vzc2xpc3RcbiAgICAgICAgV0hFUkUgKHVzZXIgPSA/IEFORCBAQG1heF91c2VyX2Nvbm5lY3Rpb25zID4gMCkgT1IgdHJ1ZWAsW19jZmcudXNlcl0pXG5cbiAgICAgIF91c2VkQ29ubnMgPSB7XG4gICAgICAgIHRvdGFsOiByZXN1bHRzWzBdLnRvdGFsIHx8IDAsXG4gICAgICAgIG1heEFnZTogcmVzdWx0c1swXS5tYXhfYWdlIHx8IDAsXG4gICAgICAgIHVwZGF0ZWQ6IERhdGUubm93KClcbiAgICAgIH1cblxuICAgIH0gLy8gZW5kIGlmIHJlZnJlc2hpbmcgY2FjaGVcblxuICAgIHJldHVybiBfdXNlZENvbm5zXG5cbiAgfSAvLyBlbmQgZ2V0VG90YWxDb25uZWN0aW9uc1xuXG5cbiAgLy8gS2lsbCBhbGwgem9tYmllIGNvbm5lY3Rpb25zIHRoYXQgYXJlIG9sZGVyIHRoYW4gdGhlIHRocmVzaG9sZFxuICBjb25zdCBraWxsWm9tYmllQ29ubmVjdGlvbnMgPSBhc3luYyAodGltZW91dCkgPT4ge1xuXG4gICAgbGV0IGtpbGxlZFpvbWJpZXMgPSAwXG5cbiAgICAvLyBIdW50IGZvciB6b21iaWVzIChqdXN0IHRoZSBzbGVlcGluZyBvbmVzIHRoYXQgdGhpcyB1c2VyIG93bnMpXG4gICAgbGV0IHpvbWJpZXMgPSBhd2FpdCBxdWVyeShcbiAgICAgIGBTRUxFQ1QgSUQsdGltZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5wcm9jZXNzbGlzdFxuICAgICAgICBXSEVSRSBjb21tYW5kID0gJ1NsZWVwJyBBTkQgdGltZSA+PSA/IEFORCB1c2VyID0gP1xuICAgICAgICBPUkRFUiBCWSB0aW1lIERFU0NgLFxuICAgICAgWyFpc05hTih0aW1lb3V0KSA/IHRpbWVvdXQgOiA2MCoxNSwgX2NmZy51c2VyXSlcblxuICAgIC8vIEtpbGwgem9tYmllc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgem9tYmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcXVlcnkoJ0tJTEwgPycsem9tYmllc1tpXS5JRClcbiAgICAgICAgb25LaWxsKHpvbWJpZXNbaV0pIC8vIGZpcmUgb25LaWxsIGV2ZW50XG4gICAgICAgIGtpbGxlZFpvbWJpZXMrK1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIGlmIChlLmNvZGUgIT09ICdFUl9OT19TVUNIX1RIUkVBRCcpIGNvbnNvbGUubG9nKGUpXG4gICAgICAgIG9uS2lsbEVycm9yKGUpIC8vIGZpcmUgb25LaWxsRXJyb3IgZXZlbnRcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBmb3JcblxuICAgIHJldHVybiBraWxsZWRab21iaWVzXG5cbiAgfSAvLyBlbmQga2lsbFpvbWJpZUNvbm5lY3Rpb25zXG5cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKiAgVFJBTlNBQ1RJT04gTUFOQUdFTUVOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8vIEluaXQgYSB0cmFuc2FjdGlvbiBvYmplY3QgYW5kIHJldHVybiBtZXRob2RzXG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gKCkgPT4ge1xuXG4gICAgbGV0IHF1ZXJpZXMgPSBbXSAvLyBrZWVwIHRyYWNrIG9mIHF1ZXJpZXNcbiAgICBsZXQgcm9sbGJhY2sgPSAoKSA9PiB7fSAvLyBkZWZhdWx0IHJvbGxiYWNrIGV2ZW50XG5cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcnk6IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcXVlcmllcy5wdXNoKGFyZ3NbMF0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVlcmllcy5wdXNoKCgpID0+IFsuLi5hcmdzXSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIHJvbGxiYWNrOiBmdW5jdGlvbihmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7IHJvbGxiYWNrID0gZm4gfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIGNvbW1pdDogYXN5bmMgZnVuY3Rpb24oKSB7IHJldHVybiBhd2FpdCBjb21taXQocXVlcmllcyxyb2xsYmFjaykgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbW1pdCB0cmFuc2FjdGlvbiBieSBydW5uaW5nIHF1ZXJpZXNcbiAgY29uc3QgY29tbWl0ID0gYXN5bmMgKHF1ZXJpZXMscm9sbGJhY2spID0+IHtcblxuICAgIGxldCByZXN1bHRzID0gW10gLy8ga2VlcCB0cmFjayBvZiByZXN1bHRzXG5cbiAgICAvLyBTdGFydCBhIHRyYW5zYWN0aW9uXG4gICAgYXdhaXQgcXVlcnkoJ1NUQVJUIFRSQU5TQUNUSU9OJylcblxuICAgIC8vIExvb3AgdGhyb3VnaCBxdWVyaWVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWVyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBFeGVjdXRlIHRoZSBxdWVyaWVzLCBwYXNzIHRoZSByb2xsYmFjayBhcyBjb250ZXh0XG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnkuYXBwbHkoe3JvbGxiYWNrfSxxdWVyaWVzW2ldKHJlc3VsdHNbcmVzdWx0cy5sZW5ndGgtMV0scmVzdWx0cykpXG4gICAgICAvLyBBZGQgdGhlIHJlc3VsdCB0byB0aGUgbWFpbiByZXN1bHRzIGFjY3VtdWxhdG9yXG4gICAgICByZXN1bHRzLnB1c2gocmVzdWx0KVxuICAgIH1cblxuICAgIC8vIENvbW1pdCBvdXIgdHJhbnNhY3Rpb25cbiAgICBhd2FpdCBxdWVyeSgnQ09NTUlUJylcblxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0c1xuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyoqICBJTklUSUFMSVpBVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIGNvbnN0IGNmZyA9IHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtcykgPyBwYXJhbXMgOiB7fVxuXG4gIE1ZU1FMID0gY2ZnLmxpYnJhcnkgfHwgcmVxdWlyZSgnbXlzcWwnKVxuICBQcm9taXNlTGlicmFyeSA9IGNmZy5wcm9taXNlIHx8IFByb21pc2VcblxuICAvLyBTZXQgZGVmYXVsdHMgZm9yIGNvbm5lY3Rpb24gbWFuYWdlbWVudFxuICBtYW5hZ2VDb25ucyA9IGNmZy5tYW5hZ2VDb25ucyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlXG4gIGNhcCA9IE51bWJlci5pc0ludGVnZXIoY2ZnLmNhcCkgPyBjZmcuY2FwIDogMTAwIC8vIGRlZmF1bHQgdG8gMTAwIG1zXG4gIGJhc2UgPSBOdW1iZXIuaXNJbnRlZ2VyKGNmZy5iYXNlKSA/IGNmZy5iYXNlIDogMiAvLyBkZWZhdWx0IHRvIDIgbXNcbiAgbWF4UmV0cmllcyA9IE51bWJlci5pc0ludGVnZXIoY2ZnLm1heFJldHJpZXMpID8gY2ZnLm1heFJldHJpZXMgOiA1MCAvLyBkZWZhdWx0IHRvIDUwIGF0dGVtcHRzXG4gIGJhY2tvZmYgPSB0eXBlb2YgY2ZnLmJhY2tvZmYgPT09ICdmdW5jdGlvbicgPyBjZmcuYmFja29mZiA6XG4gICAgY2ZnLmJhY2tvZmYgJiYgWydmdWxsJywnZGVjb3JyZWxhdGVkJ10uaW5jbHVkZXMoY2ZnLmJhY2tvZmYudG9Mb3dlckNhc2UoKSkgP1xuICAgICAgY2ZnLmJhY2tvZmYudG9Mb3dlckNhc2UoKSA6ICdmdWxsJyAvLyBkZWZhdWx0IHRvIGZ1bGwgSml0dGVyXG4gIGNvbm5VdGlsaXphdGlvbiA9ICFpc05hTihjZmcuY29ublV0aWxpemF0aW9uKSA/IGNmZy5jb25uVXRpbGl6YXRpb24gOiAwLjggLy8gZGVmYXVsdCB0byAwLjdcbiAgem9tYmllTWluVGltZW91dCA9IE51bWJlci5pc0ludGVnZXIoY2ZnLnpvbWJpZU1pblRpbWVvdXQpID8gY2ZnLnpvbWJpZU1pblRpbWVvdXQgOiAzIC8vIGRlZmF1bHQgdG8gMyBzZWNvbmRzXG4gIHpvbWJpZU1heFRpbWVvdXQgPSBOdW1iZXIuaXNJbnRlZ2VyKGNmZy56b21iaWVNYXhUaW1lb3V0KSA/IGNmZy56b21iaWVNYXhUaW1lb3V0IDogNjAqMTUgLy8gZGVmYXVsdCB0byAxNSBtaW51dGVzXG4gIG1heENvbm5zRnJlcSA9IE51bWJlci5pc0ludGVnZXIoY2ZnLm1heENvbm5zRnJlcSkgPyBjZmcubWF4Q29ubnNGcmVxIDogMTUqMTAwMCAvLyBkZWZhdWx0IHRvIDE1IHNlY29uZHNcbiAgdXNlZENvbm5zRnJlcSA9IE51bWJlci5pc0ludGVnZXIoY2ZnLnVzZWRDb25uc0ZyZXEpID8gY2ZnLnVzZWRDb25uc0ZyZXEgOiAwIC8vIGRlZmF1bHQgdG8gMCBtc1xuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG4gIG9uQ29ubmVjdCA9IHR5cGVvZiBjZmcub25Db25uZWN0ID09PSAnZnVuY3Rpb24nID8gY2ZnLm9uQ29ubmVjdCA6ICgpID0+IHt9XG4gIG9uQ29ubmVjdEVycm9yID0gdHlwZW9mIGNmZy5vbkNvbm5lY3RFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGNmZy5vbkNvbm5lY3RFcnJvciA6ICgpID0+IHt9XG4gIG9uUmV0cnkgPSB0eXBlb2YgY2ZnLm9uUmV0cnkgPT09ICdmdW5jdGlvbicgPyBjZmcub25SZXRyeSA6ICgpID0+IHt9XG4gIG9uQ2xvc2UgPSB0eXBlb2YgY2ZnLm9uQ2xvc2UgPT09ICdmdW5jdGlvbicgPyBjZmcub25DbG9zZSA6ICgpID0+IHt9XG4gIG9uRXJyb3IgPSB0eXBlb2YgY2ZnLm9uRXJyb3IgPT09ICdmdW5jdGlvbicgPyBjZmcub25FcnJvciA6ICgpID0+IHt9XG4gIG9uS2lsbCA9IHR5cGVvZiBjZmcub25LaWxsID09PSAnZnVuY3Rpb24nID8gY2ZnLm9uS2lsbCA6ICgpID0+IHt9XG4gIG9uS2lsbEVycm9yID0gdHlwZW9mIGNmZy5vbktpbGxFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGNmZy5vbktpbGxFcnJvciA6ICgpID0+IHt9XG5cbiAgbGV0IGNvbm5DZmcgPSB7fVxuICBcbiAgaWYgKHR5cGVvZiBjZmcuY29uZmlnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShjZmcuY29uZmlnKSkge1xuICAgIGNvbm5DZmcgPSBjZmcuY29uZmlnXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25uQ2ZnID0gcGFyYW1zXG4gIH1cblxuICBsZXQgZXNjYXBlID0gTVlTUUwuZXNjYXBlXG4gIGxldCBlc2NhcGVJZCA9IE1ZU1FMLmVzY2FwZUlkXG4gIGxldCBmb3JtYXQgPSBNWVNRTC5mb3JtYXRcblxuICAvLyBTZXQgTXlTUUwgY29uZmlnc1xuICBjb25maWcoY29ubkNmZylcblxuXG4gIC8vIFJldHVybiBwdWJsaWMgbWV0aG9kc1xuICByZXR1cm4ge1xuICAgIGNvbm5lY3QsXG4gICAgY29uZmlnLFxuICAgIHF1ZXJ5LFxuICAgIGVuZCxcbiAgICBlc2NhcGUsXG4gICAgZXNjYXBlSWQsXG4gICAgZm9ybWF0LFxuICAgIHF1aXQsXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgZ2V0Q291bnRlcixcbiAgICBnZXRDbGllbnQsXG4gICAgZ2V0Q29uZmlnLFxuICAgIGdldEVycm9yQ291bnRcbiAgfVxuXG59IC8vIGVuZCBleHBvcnRzXG4iXSwibmFtZXMiOlsiTm9kZVVSTCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyYW1zIiwiY2xpZW50IiwiY291bnRlciIsImVycm9ycyIsInJldHJpZXMiLCJfY2ZnIiwiX21heENvbm5zIiwidXBkYXRlZCIsIl91c2VkQ29ubnMiLCJ0b29NYW55Q29ubnNFcnJvcnMiLCJNWVNRTCIsIm1hbmFnZUNvbm5zIiwiY2FwIiwiYmFzZSIsIm1heFJldHJpZXMiLCJjb25uVXRpbGl6YXRpb24iLCJiYWNrb2ZmIiwiem9tYmllTWluVGltZW91dCIsInpvbWJpZU1heFRpbWVvdXQiLCJtYXhDb25uc0ZyZXEiLCJ1c2VkQ29ubnNGcmVxIiwib25Db25uZWN0Iiwib25Db25uZWN0RXJyb3IiLCJvblJldHJ5Iiwib25DbG9zZSIsIm9uRXJyb3IiLCJvbktpbGwiLCJvbktpbGxFcnJvciIsIlByb21pc2VMaWJyYXJ5IiwiZ2V0Q291bnRlciIsImluY0NvdW50ZXIiLCJyZXNldENvdW50ZXIiLCJnZXRDbGllbnQiLCJyZXNldENsaWVudCIsInJlc2V0UmV0cmllcyIsImdldEVycm9yQ291bnQiLCJnZXRDb25maWciLCJjb25maWciLCJhcmdzIiwiT2JqZWN0IiwiYXNzaWduIiwidXJpVG9Db25uZWN0aW9uQ29uZmlnIiwiZGVsYXkiLCJtcyIsInJlcyIsInNldFRpbWVvdXQiLCJyYW5kUmFuZ2UiLCJtaW4iLCJtYXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJmdWxsSml0dGVyIiwiZGVjb3JyZWxhdGVkSml0dGVyIiwic2xlZXAiLCJjb25uZWN0aW9uU3RyaW5nIiwidXJpIiwidW5kZWZpbmVkIiwiVVJMIiwiZXJyb3IiLCJFcnJvciIsImV4dHJhRmllbGRzIiwibmFtZSIsInZhbHVlIiwic2VhcmNoUGFyYW1zIiwiZGF0YWJhc2UiLCJwYXRobmFtZSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImNvbm5lY3Rpb25GaWVsZHMiLCJob3N0IiwiaG9zdG5hbWUiLCJ1c2VyIiwidXNlcm5hbWUiLCJwb3J0IiwiTnVtYmVyIiwicGFzc3dvcmQiLCJjb25uZWN0Iiwid2FpdCIsIl9jb25uZWN0IiwiZSIsImluY2x1ZGVzIiwiY29kZSIsImlzSW50ZWdlciIsInRoZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiY3JlYXRlQ29ubmVjdGlvbiIsImVyciIsIm9uIiwiZW5kIiwibWF4Q29ubnMiLCJnZXRNYXhDb25uZWN0aW9ucyIsInVzZWRDb25ucyIsImdldFRvdGFsQ29ubmVjdGlvbnMiLCJ0b3RhbCIsInRpbWVvdXQiLCJtYXhBZ2UiLCJraWxsZWRab21iaWVzIiwia2lsbFpvbWJpZUNvbm5lY3Rpb25zIiwicXVpdCIsInF1ZXJ5Iiwicm9sbGJhY2siLCJsZW5ndGgiLCJyZXN1bHRzIiwiZGVzdHJveSIsInRlc3QiLCJEYXRlIiwibm93IiwidXNlckxpbWl0IiwibWF4X2FnZSIsInpvbWJpZXMiLCJpc05hTiIsImkiLCJJRCIsInRyYW5zYWN0aW9uIiwicXVlcmllcyIsInB1c2giLCJmbiIsImNvbW1pdCIsInJlc3VsdCIsImFwcGx5IiwiY2ZnIiwiQXJyYXkiLCJpc0FycmF5IiwibGlicmFyeSIsInByb21pc2UiLCJQcm9taXNlIiwidG9Mb3dlckNhc2UiLCJjb25uQ2ZnIiwiZXNjYXBlIiwiZXNjYXBlSWQiLCJmb3JtYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/serverless-mysql/index.js\n");

/***/ })

};
;